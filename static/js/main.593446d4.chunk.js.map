{"version":3,"sources":["Logger.js","components/FolderPicker/FolderPicker.js","components/FileListChooser/FileListChooser.js","components/TagPicker/TagPicker.js","components/TagFilePreview/TagFilePreview.js","TagData.js","components/TagFilePicker/TagFilePicker.js","App.js","serviceWorker.js","index.js","logo.svg"],"names":["Logger","this","ENABLE_LOGGING","console","log","apply","arguments","time","timeEnd","FolderPicker","props","id","type","webkitdirectory","directory","onChange","event","target","files","FileListChooser","React","Component","constructor","super","state","data","cloneFileListToTableData","bind","handleSelectionChange","componentDidMount","setState","alreadyChosenPaths","canSelect","componentDidUpdate","prevProps","isEqual","tableData","map","file","index","name","webkitRelativePath","lastModified","size","checked","includes","disabled","rows","onSelectionChange","row","getImageForIndex","alt","src","URL","createObjectURL","style","maxWidth","render","title","options","selection","searchFieldAlignment","paging","maxBodyHeight","selectionProps","rowData","columns","field","defaultProps","filter","createFilterOptions","TagPicker","Autocomplete","selectOnFocus","clearOnBlur","handleHomeEndKeys","value","tag","newValue","onTagChange","inputValue","onNewTag","tagList","renderOption","option","filterOptions","params","filtered","matchingElem","find","element","push","width","renderInput","TextField","label","variant","darkgrey","grey","TagFilePreview","downloadTagFile","codeString","blob","Blob","saveAs","JSON","stringify","contents","Box","Alert","severity","Button","color","onClick","language","monokaiSublime","customStyle","height","showLineNumbers","showInlineLineNumbers","lineNumberStyle","getPathString","File","String","Error","TagData","optExistingFileOrInstance","optExistingPrefix","tags","sets","prefix","Object","entries","uniformlyPrefixedFilePathArray","filePath","newFilePath","startsWith","setFilesForTag","clone","changeFilePrefix","newPrefix","filePathArray","replace","toJSON","getTagList","keys","getPathListForTagWithoutPrefix","theTag","tagExists","pathList","path","addTag","newTag","Array","isArray","fromPairs","sortBy","toPairs","removeTag","oldTag","addFilesToTag","forEach","newPathString","sort","optSkipPrefixing","uniq","removeFilesFromTag","filePathsToRemove","pull","TagFilePicker","isStringWithValue","theString","isEmpty","trim","App","process","overrideLoggingSetting","URLSearchParams","window","location","search","get","Boolean","objectsDirFiles","tagsFileContents","handleObjectsDirChange","addNewTagAndSetCurrent","associateFilesToCurrentTag","handleTagChange","handleInputTagsFileChange","length","reader","FileReader","that","onload","result","foo","parse","tagData","initialTags","initialTag","readAsText","theNewTag","tempTagData","tagChooser","tagFileChooser","tagFilePreview","canSelectFiles","Card","CardContent","Typography","Container","Divider","Paper","Accordion","AccordionSummary","expandIcon","aria-controls","className","align","rel","href","fontWeight","hostname","match","ReactDOM","StrictMode","CssBaseline","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message","module","exports"],"mappings":"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","file":"static/js/main.593446d4.chunk.js","sourcesContent":["class _Logger {\r\n\r\n    constructor() {\r\n        this.ENABLE_LOGGING = false;\r\n    }\r\n\r\n    log() {\r\n        if (this.ENABLE_LOGGING) {\r\n            console.log.apply(null, arguments);\r\n        }\r\n    }\r\n\r\n    time() {\r\n        if (this.ENABLE_LOGGING) {\r\n            console.time.apply(null, arguments);\r\n        }\r\n    }\r\n\r\n    timeEnd() {\r\n        if (this.ENABLE_LOGGING) {\r\n            console.timeEnd.apply(null, arguments);\r\n        }\r\n    }\r\n}\r\n\r\nconst Logger = new _Logger();\r\nexport default Logger;","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport Logger from '../../Logger';\r\nimport './FolderPicker.css';\r\n\r\nfunction FolderPicker(props) {\r\n    function handleFolderChange(event) {\r\n        props.onChange(event.target.files);\r\n    }\r\n\r\n  return (\r\n    <input id=\"myInput\" type=\"file\" webkitdirectory=\"true\" directory=\"true\" onChange={handleFolderChange}/>\r\n  );\r\n}\r\n\r\nFolderPicker.propTypes = {\r\n    onChange: PropTypes.func.isRequired\r\n}\r\n\r\nexport default FolderPicker;\r\n","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport MaterialTable from 'material-table'\r\nimport isEqual from 'lodash/isEqual';\r\nimport Logger from '../../Logger';\r\nimport './FileListChooser.css';\r\n\r\nclass FileListChooser extends React.Component {\r\n\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            data: [],\r\n        };\r\n        this.cloneFileListToTableData = this.cloneFileListToTableData.bind(this);\r\n        this.handleSelectionChange = this.handleSelectionChange.bind(this);\r\n    }\r\n\r\n    componentDidMount() {\r\n        Logger.log('FileListChooser:componentDidMount');\r\n        Logger.log('  -> this.props.files',this.props.files);\r\n        if (this.props.files) {\r\n            Logger.log('  -> Files Supplied...Replacing Component State Data...');\r\n            this.setState((state,props) => {\r\n                return {\r\n                    data: this.cloneFileListToTableData(props.files, props.alreadyChosenPaths, props.canSelect)\r\n                };\r\n            });\r\n        }\r\n    }\r\n\r\n    componentDidUpdate(prevProps) {\r\n        Logger.log('FileListChooser:componentDidUpdate');\r\n        Logger.log('  -> prevProps', prevProps);\r\n        Logger.log('  -> prevProps', prevProps);\r\n        Logger.log('  -> this.props.files', this.props.files);\r\n        if (prevProps.files !== this.props.files || !isEqual(prevProps.alreadyChosenPaths, this.props.alreadyChosenPaths) || prevProps.canSelect !== this.props.canSelect) {\r\n            Logger.log('  -> Changing...Replacing Component State Data...');\r\n            this.setState((state,props) => {\r\n                return {\r\n                    data: this.cloneFileListToTableData(props.files, props.alreadyChosenPaths, props.canSelect)\r\n                };\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Given a FileList, will clone these into plain objects. Handles arrays fine too\r\n     *\r\n     * The table library used will mutate the data supplied to it, to track various things\r\n     *  so it's necessary to take a deep copy instead of using props\r\n     *\r\n     * As a File is technically a Blob, cloning libraries struggle with it, so the simples\r\n     * solution is just to copy what we want (which is just the info fields) ourselves,\r\n     * and set the special var used for indicating selection in the table\r\n     *\r\n     * @param {FileList} files A FileList (or an Array of Files)\r\n     * @param {Array[string]} alreadyChosenPaths An array of strings of paths that should be ticked\r\n     * @param {boolean} canSelect whether we can select files or not\r\n     */\r\n    cloneFileListToTableData(files, alreadyChosenPaths, canSelect) {\r\n        Logger.log('FileListChooser:this.cloneFileListToTableData');\r\n        let filesArray = [...files]; //Can be an array-like FileList (cf. https://stackoverflow.com/questions/25333488)\r\n        let tableData = filesArray.map((file, index) => ({\r\n            name: file.name,\r\n            webkitRelativePath: file.webkitRelativePath,\r\n            type: file.type,\r\n            lastModified: file.lastModified,\r\n            size: file.size,\r\n            index: index,\r\n            tableData: {\r\n                //Table library specific configuration\r\n                checked: alreadyChosenPaths.includes(file.webkitRelativePath),\r\n                disabled: !canSelect\r\n            }\r\n        }));\r\n        Logger.log('  -> new tableData', tableData);\r\n        return tableData;\r\n    }\r\n\r\n    handleSelectionChange(rows) {\r\n        Logger.log('FileListChooser:handleSelectionChange');\r\n        Logger.time('FileListChooser:handleSelectionChange');\r\n        this.props.onSelectionChange(rows.map(row=>row.webkitRelativePath));\r\n        Logger.timeEnd('FileListChooser:handleSelectionChange');\r\n    }\r\n\r\n    getImageForIndex(index) {\r\n        return <img alt=\"Object\" src={URL.createObjectURL(this.props.files[index])} style={{maxWidth: 120}} />;\r\n    }\r\n\r\n\r\n    render() {\r\n\r\n        return (\r\n            <MaterialTable\r\n                title=\"\"\r\n                options={{\r\n                    selection: true,\r\n                    searchFieldAlignment: \"left\",\r\n                    paging: false,\r\n                    maxBodyHeight: 600,\r\n                    selectionProps: (rowData)=>({disabled: rowData.tableData.disabled})\r\n                }}\r\n                onSelectionChange={this.handleSelectionChange}\r\n                columns={[\r\n                    { title: 'Name', field: 'name' },\r\n                    { title: 'Location', field: 'webkitRelativePath' },\r\n                    {\r\n                        title: 'Image',\r\n                        field: 'webkitRelativePath',\r\n                        render: (rowData) => this.getImageForIndex(rowData.index)\r\n                    }\r\n                ]}\r\n                data={this.state.data}\r\n            />\r\n        );\r\n    }\r\n}\r\n\r\nFileListChooser.propTypes = {\r\n    files: PropTypes.arrayOf(PropTypes.shape({\r\n        name: PropTypes.string,\r\n        webkitRelativePath: PropTypes.number, // Used as the unique identifier for a given record\r\n        type: PropTypes.string,\r\n        selected: PropTypes.bool\r\n    })).isRequired,\r\n    //An array containing any paths that should already be ticked\r\n    alreadyChosenPaths: PropTypes.arrayOf(PropTypes.string).isRequired,\r\n    //will be called on any select/deselect, and contains an array of the webkitRelativePath of all Files that are currently selected. Anything NOT in the\r\n    // array (but that was in your initial data set) is NOT selected.\r\n    onSelectionChange: PropTypes.func.isRequired,\r\n    //Whether the selection checkboxes are enabled. Defaults to true\r\n    canSelect: PropTypes.bool\r\n}\r\n\r\nFileListChooser.defaultProps = {\r\n    canSelect: true\r\n}\r\n\r\nexport default FileListChooser;\r\n","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport Autocomplete, { createFilterOptions } from '@material-ui/lab/Autocomplete';\r\nimport Logger from '../../Logger';\r\nimport './TagPicker.css';\r\n\r\nconst filter = createFilterOptions();\r\n\r\nclass TagPicker extends React.Component {\r\n\r\n    render() {\r\n        return (\r\n            <Autocomplete\r\n                selectOnFocus\r\n                clearOnBlur\r\n                handleHomeEndKeys\r\n                id=\"TagPicker\"\r\n                value={this.props.tag}\r\n                onChange={(event, newValue) => {\r\n                    if (typeof newValue === 'string') {\r\n                        this.props.onTagChange(newValue);\r\n                    } else if (newValue && newValue.inputValue) {\r\n                        //New tag process is now in flight\r\n                        this.props.onNewTag(newValue.inputValue)\r\n                    }\r\n                }}\r\n                options={this.props.tagList}\r\n                renderOption={(option) => {\r\n                    if (typeof option === 'string') {\r\n                        return option;\r\n                    } else {\r\n                        //Account for the \"Create New Tag\" option\r\n                        return option.title;\r\n                    }\r\n                }}\r\n                filterOptions={(options, params) => {\r\n                    const filtered = filter(options, params);\r\n\r\n                    const matchingElem = options.find(element => element === params.inputValue);\r\n\r\n                    // Suggest the creation of a new value - as an object to distinguish it from regular tags,\r\n                    //   and to allow us to distinguish the tag value from the display value\r\n                    if (params.inputValue !== '' && !matchingElem) {\r\n                        filtered.push({\r\n                            inputValue: params.inputValue,\r\n                            title: `Create New Tag \"${params.inputValue}\"`,\r\n                        });\r\n                    }\r\n\r\n                    return filtered;\r\n                }}\r\n                style={{ width: 300 }}\r\n                renderInput={(params) => (\r\n                    <TextField {...params} label=\"Choose/Create a tag\" variant=\"outlined\" />\r\n                )}\r\n            />\r\n        );\r\n    }\r\n}\r\n\r\nTagPicker.propTypes = {\r\n    //The current tag\r\n    tag: PropTypes.string.isRequired,\r\n    //Called with the new active tag string, when the user changes the active tag\r\n    onTagChange: PropTypes.func.isRequired,\r\n    //An array of String tags\r\n    tagList: PropTypes.arrayOf(PropTypes.string).isRequired,\r\n    //Function will be invoked with a string if the user wants a new tag. The function should do whatever it needs to, but also add\r\n    //  the value to the tagList prop.\r\n    //  This component will then check if the tag is now present in tagList, and set the selected value to the requested new tag if it is\r\n    onNewTag: PropTypes.func.isRequired\r\n}\r\n\r\nexport default TagPicker;\r\n","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport Button from '@material-ui/core/Button';\r\nimport { Alert, AlertTitle } from '@material-ui/lab';\r\nimport SyntaxHighlighter from 'react-syntax-highlighter';\r\nimport { monokaiSublime } from 'react-syntax-highlighter/dist/esm/styles/hljs';\r\nimport { saveAs } from 'file-saver';\r\nimport './TagFilePreview.css';\r\nimport { Box } from '@material-ui/core';\r\nimport { grey } from '@material-ui/core/colors';\r\n\r\nconst darkgrey = grey[600];\r\n\r\nclass TagFilePreview extends React.Component {\r\n\r\n\r\n    downloadTagFile(codeString) {\r\n        var blob = new Blob([codeString], {type : 'text/text;charset=utf-8\"'}); //really, it's a JSON file, but anything other than this causes rogue extensions to be added by browsers (which may happen anyway!)\r\n        saveAs(blob, \"default.dungeondraft_tags\");\r\n    }\r\n\r\n    render() {\r\n        const codeString = JSON.stringify(this.props.contents, null, '\\t');\r\n        return (\r\n            <Box>\r\n                <Alert severity=\"info\">\r\n                    Note when saving - some browsers and operating systems will automatically add an unwanted extension to the filename. If this happens, rename the file to \"default.dungeondraft_tags\"\r\n                </Alert>\r\n                <Button variant=\"contained\" color=\"secondary\" onClick={()=>{this.downloadTagFile(codeString)}}>\r\n                    Download Tag File\r\n                </Button>\r\n                <SyntaxHighlighter language=\"javascript\" style={monokaiSublime} customStyle={{height: 500}} showLineNumbers=\"true\" showInlineLineNumbers=\"true\" lineNumberStyle={{color: darkgrey}}>\r\n                    {codeString}\r\n                </SyntaxHighlighter>\r\n            </Box>\r\n        );\r\n    }\r\n}\r\n\r\nTagFilePreview.propTypes = {\r\n    contents: PropTypes.object.isRequired //should be of type TagData\r\n}\r\n\r\nexport default TagFilePreview;\r\n","import uniq from 'lodash/uniq';\r\nimport pull from 'lodash/pull';\r\nimport toPairs from 'lodash/toPairs';\r\nimport sortBy from 'lodash/sortBy';\r\nimport fromPairs from 'lodash/fromPairs';\r\nimport clone from 'lodash/clone';\r\nimport Logger from './Logger';\r\n\r\n/**\r\n * Get the path to a file\r\n * @param {File|string} file Either a File object or a string representing the path to a file\r\n */\r\nfunction getPathString(file) {\r\n    if (file instanceof File) {\r\n        return file.webkitRelativePath;\r\n    } else if (file instanceof String || typeof file === \"string\") {\r\n        return file;\r\n    } else {\r\n        throw new Error('Expected either a File or string');\r\n    }\r\n}\r\n\r\nclass TagData {\r\n\r\n    constructor(optExistingFileOrInstance,optExistingPrefix) {\r\n        this.tags = {};\r\n        this.sets = {};\r\n        this.prefix = 'textures/'; //default, can be overriden (may properly hardcode in future though)\r\n\r\n        if (optExistingFileOrInstance) {\r\n            //Reconstruct. This will have the effect of correcting the following:\r\n            // - missing array for a tag key\r\n            // - unsorted tags\r\n            // - unsorted tag files\r\n            // - duplicate tag files\r\n            // - duplicate tags (will merge them)\r\n            // - making the prefix uniform - setting it to 'textures/'. Existing paths will otherwise be untouched\r\n            for (const [tag,filePathArray] of Object.entries(optExistingFileOrInstance.tags)) {\r\n                let uniformlyPrefixedFilePathArray = filePathArray.map(filePath=>{\r\n                    let newFilePath = filePath;\r\n                    if (!filePath.startsWith(this.prefix)) {\r\n                        newFilePath = this.prefix + newFilePath;\r\n                    }\r\n                    return newFilePath;\r\n                });\r\n                this.setFilesForTag(tag,uniformlyPrefixedFilePathArray,true);\r\n            }\r\n\r\n            if (typeof optExistingFileOrInstance.sets === 'object') {\r\n                this.sets = optExistingFileOrInstance.sets\r\n            }\r\n        }\r\n    }\r\n\r\n    clone() {\r\n        return new TagData(this);\r\n    }\r\n\r\n    changeFilePrefix(newPrefix) {\r\n        for (const [tag,filePathArray] of Object.entries(this.tags)) {\r\n            this.tags[tag] = filePathArray.map(filePath=>{\r\n                let newFilePath = filePath;\r\n                if (filePath.startsWith(this.prefix)) {\r\n                    newFilePath = filePath.replace(this.prefix,newPrefix);\r\n                } else {\r\n                    newFilePath = newPrefix + newFilePath;\r\n                }\r\n                return newFilePath;\r\n            });\r\n        }\r\n        this.prefix = newPrefix;\r\n    }\r\n\r\n    toJSON() {\r\n        //only include the tags and sets properties\r\n        return {\r\n            tags: this.tags,\r\n            sets: this.sets\r\n        }\r\n    }\r\n\r\n\r\n    getTagList() {\r\n        return Object.keys(this.tags);\r\n    }\r\n\r\n    /**\r\n     * Get a list of all paths for a tag, but without the prefix\r\n     */\r\n    getPathListForTagWithoutPrefix(theTag) {\r\n        Logger.log('TagData:getPathListForTagWithoutPrefix');\r\n        if (this.tagExists(theTag)) {\r\n            let pathList = this.tags[theTag].map(path => {\r\n                return path.startsWith(this.prefix) ? path.replace(this.prefix,'') : path;\r\n            });\r\n            Logger.log('  -> returning pathList', pathList);\r\n            return pathList;\r\n        }\r\n        Logger.log('  -> Tag does not exist');\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Check if the tag exists - NOTE: does not validate that it has an array - could be null, undefined, etc.\r\n     *\r\n     * Prefer addTag - it always ensures there's an array - even if the\r\n     *\r\n     * @param {string} theTag the tag\r\n     */\r\n    tagExists(theTag) {\r\n        return theTag in this.tags;\r\n    }\r\n\r\n    /**\r\n     * Add a new tag, if it doesn't exist already. If it does, also ensure that it has an array\r\n     * @param {string} newTag the new tag to add\r\n     */\r\n    addTag(newTag) {\r\n        Logger.log('TagData:addTag');\r\n        Logger.log('  -> newTag', newTag);\r\n        if (newTag in this.tags) {\r\n            Logger.log('  -> Already exists, returning early...');\r\n            if (!Array.isArray(this.tags[newTag])) {\r\n                Logger.log('  -> Wasn\\'t an array, setting to an empty array');\r\n                this.tags[newTag] = [];\r\n            }\r\n            return;\r\n        }\r\n        //Keep the tag keys sorted, for human readability\r\n        this.tags[newTag] = [];\r\n        this.tags = fromPairs(sortBy(toPairs(this.tags)));\r\n    }\r\n\r\n    /**\r\n     * Remove a tag - NOTE that this will completely remove all entries for the tag,\r\n     * with no ability to restore them\r\n     * @param {string} oldTag the old tag to remove\r\n     */\r\n    removeTag(oldTag) {\r\n        delete this.tags[oldTag];\r\n    }\r\n\r\n    /**\r\n     * Add file paths to a tag, maintaining uniqueness and sort order\r\n     *\r\n     * Will create the tag if it does not exist already.\r\n     *\r\n     * @param {string} tag the tag\r\n     * @param {FileList|Array[File]} files the list of files\r\n     */\r\n    addFilesToTag(tag, files) {\r\n        this.addTag(tag); //ensure the tag exists\r\n        let filePathArray = this.tags[tag];\r\n        files.forEach(file => {\r\n            let newPathString = this.prefix + getPathString(file);\r\n            //Uniqueness check\r\n            if (!filePathArray.includes(newPathString)) {\r\n                filePathArray.push(newPathString);\r\n            }\r\n        });\r\n        filePathArray.sort();\r\n        this.tags[tag] = filePathArray;\r\n    }\r\n\r\n    /**\r\n     * Replace the existing list of files for a tag with a new list of files.\r\n     *\r\n     * Will create the tag if it does not exist already.\r\n     *\r\n     * @param {string} tag the tag\r\n     * @param {FileList|Array[File]} files the list of files\r\n     * @param {boolean} optSkipPrefixing optionally skip prefixing - should only be used when rehydrating using known data\r\n     */\r\n    setFilesForTag(tag, files, optSkipPrefixing) {\r\n        Logger.time('TagData:setFilesForTag');\r\n        this.addTag(tag); //ensure the tag exists\r\n        let filePathArray = [];\r\n        files.forEach(file => {\r\n            filePathArray.push((optSkipPrefixing ? '' : this.prefix) + getPathString(file));\r\n        });\r\n        filePathArray = uniq(filePathArray); //ensure the supplied list doesn't have dups\r\n        filePathArray.sort();\r\n        this.tags[tag] = filePathArray;\r\n        Logger.timeEnd('TagData:setFilesForTag');\r\n    }\r\n\r\n    /**\r\n     * Remove file paths from a tag\r\n     *\r\n     * Will create the tag if it does not exist already.\r\n     *\r\n     * @param {string} tag the tag\r\n     * @param {FileList|Array[File]} files the list of files\r\n     */\r\n    removeFilesFromTag(tag, files) {\r\n        this.addTag(tag); //ensure the tag exists\r\n        let filePathArray = this.tags[tag];\r\n        let filePathsToRemove = [];\r\n        files.forEach(file => {\r\n            filePathsToRemove.push(this.prefix + getPathString(file));\r\n        });\r\n        pull(filePathArray,filePathsToRemove);\r\n        filePathArray.sort(); //shouldn't be able to get unsorted here, but why not make sure\r\n    }\r\n}\r\n\r\nexport default TagData;","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport Logger from '../../Logger';\r\nimport './TagFilePicker.css';\r\n\r\nfunction TagFilePicker(props) {\r\n    function handleFileChange(event) {\r\n        props.onChange(event.target.files);\r\n    }\r\n\r\n  return (\r\n    <input id=\"myTagFileInput\" type=\"file\" onChange={handleFileChange}/>\r\n  );\r\n}\r\n\r\nTagFilePicker.propTypes = {\r\n    onChange: PropTypes.func.isRequired\r\n}\r\n\r\nexport default TagFilePicker;\r\n","import React from 'react';\nimport logo from './logo.svg';\nimport { Container, Box, Typography, Divider, Paper, Card, CardContent, Accordion, AccordionSummary } from '@material-ui/core';\nimport { makeStyles } from '@material-ui/core/styles';\nimport { Alert, AlertTitle } from '@material-ui/lab';\nimport TextField from '@material-ui/core/TextField';\nimport Autocomplete, { createFilterOptions } from '@material-ui/lab/Autocomplete';\nimport ExpandMoreIcon from '@material-ui/icons/ExpandMore';\nimport WarningIcon from '@material-ui/icons/Warning';\nimport SentimentSatisfiedIcon from '@material-ui/icons/SentimentSatisfied';\nimport isEmpty from 'lodash/isEmpty';\n\nimport FolderPicker from './components/FolderPicker/FolderPicker.js';\nimport FileListChooser from './components/FileListChooser/FileListChooser.js';\nimport TagPicker from './components/TagPicker/TagPicker.js';\nimport TagFilePreview from './components/TagFilePreview/TagFilePreview';\nimport TagData from './TagData';\nimport Logger from './Logger';\n\nimport './App.css';\nimport TagFilePicker from './components/TagFilePicker/TagFilePicker';\n\n    // const useStyles = makeStyles((theme) => ({\n    //     root: {\n    //       width: '100%',\n    //     },\n    //     heading: {\n    //       fontSize: theme.typography.pxToRem(15),\n    //       flexBasis: '33.33%',\n    //       flexShrink: 0,\n    //     },\n    //     secondaryHeading: {\n    //       fontSize: theme.typography.pxToRem(15),\n    //       color: theme.palette.text.secondary,\n    //     },\n    //   }))();\n    // const classes = useStyles();\n\nfunction isStringWithValue(theString) {\n    return typeof theString === 'string' && !isEmpty(theString.trim())\n}\n\nclass App extends React.Component {\n\n    constructor(props) {\n        super(props);\n\n        //Check if Logging should be enabled\n        Logger.ENABLE_LOGGING = process.env.REACT_APP_ENABLE_LOGGING === 'true';\n        //Allow overriding the env setting with a url param\n        let overrideLoggingSetting = new URLSearchParams(window.location.search).get('forceLogging');\n        if (overrideLoggingSetting && (overrideLoggingSetting === 'true' || overrideLoggingSetting === 'false')) {\n            Logger.ENABLE_LOGGING = Boolean(overrideLoggingSetting);\n        }\n\n        Logger.log('App:constructor');\n        Logger.log('  -> Logger.ENABLE_LOGGING: ', Logger.ENABLE_LOGGING);\n\n        this.state = {\n            objectsDirFiles: [],\n            tag: null,\n            tagsFileContents: new TagData()\n        };\n\n        Logger.log('  -> this.state.tagsFileContents: ', this.state.tagsFileContents);\n\n        this.handleObjectsDirChange = this.handleObjectsDirChange.bind(this);\n        this.addNewTagAndSetCurrent = this.addNewTagAndSetCurrent.bind(this);\n        this.associateFilesToCurrentTag = this.associateFilesToCurrentTag.bind(this);\n        this.handleTagChange = this.handleTagChange.bind(this);\n        this.handleInputTagsFileChange = this.handleInputTagsFileChange.bind(this);\n    }\n\n    handleObjectsDirChange(files) {\n        Logger.log('App:handleObjectsDirChange');\n        this.setState((state,props) => ({\n            objectsDirFiles: [...files] //create a new array with our File objects\n        }));\n    }\n\n    handleInputTagsFileChange(files) {\n        Logger.log('App:handleInputTagsFileChange');\n        if (!files.length) {\n            return;\n        }\n        let file = files[0];\n        let reader = new FileReader();\n        var that = this;\n        reader.onload = function(event) {\n            Logger.log('  ->event.target.result', event.target.result);\n            window.foo = event.target.result;\n            Logger.log('  ->typeof event.target.result', typeof event.target.result);\n            Logger.log('  ->JSON.parse(event.target.result', JSON.parse(event.target.result));\n\n            const tagData = new TagData(JSON.parse(event.target.result));\n            const initialTags = Object.keys(tagData.tags);\n            let initialTag = initialTags.length > 0 ? initialTags[0] : null;\n            that.setState((state,props) => ({\n                tagsFileContents: tagData,\n                tag: initialTag\n            }));\n        }\n        reader.readAsText(file);\n    }\n\n    addNewTagAndSetCurrent(theNewTag) {\n        Logger.log('App:addNewTagAndSetCurrent');\n        let tempTagData = this.state.tagsFileContents.clone();\n        tempTagData.addTag(theNewTag);\n        this.setState((state,props) => ({\n            tagsFileContents: tempTagData,\n            tag: theNewTag\n        }));\n    }\n\n    handleTagChange(theNewTag) {\n        this.setState((state,props) => ({\n            tag: theNewTag\n        }));\n    }\n\n    associateFilesToCurrentTag(files) {\n        Logger.log('App:this.associateFilesToCurrentTag');\n        if (!isStringWithValue(this.state.tag)) {\n            Logger.log('  -> No tag, returning early');\n            return;\n        }\n        Logger.time('App:this.associateFilesToCurrentTag');\n        let tempTagData = this.state.tagsFileContents.clone();\n        tempTagData.setFilesForTag(this.state.tag, files);\n        Logger.log('  -> about to update tags file. new data: ', tempTagData);\n        this.setState((state,props) => ({\n            tagsFileContents: tempTagData\n        }));\n        Logger.timeEnd('App:this.associateFilesToCurrentTag');\n    }\n\n    render () {\n        let tagChooser;\n        let tagFileChooser;\n        let tagFilePreview;\n        let tagList = Object.keys(this.state.tagsFileContents.tags);\n        let canSelectFiles = isStringWithValue(this.state.tag);\n        if (this.state.objectsDirFiles && this.state.objectsDirFiles.length > 0) {\n            const alreadyChosenPaths = this.state.tagsFileContents.getPathListForTagWithoutPrefix(this.state.tag);\n            tagChooser = <Card>\n                <CardContent>\n                    <Typography variant=\"h2\">\n                        Select Tag\n                    </Typography>\n                    <TagPicker\n                        tag={this.state.tag}\n                        onTagChange={this.handleTagChange}\n                        tagList={tagList}\n                        onNewTag={this.addNewTagAndSetCurrent}\n                    />\n                </CardContent>\n            </Card>\n            tagFileChooser = <Card>\n                <CardContent>\n                    <Typography variant=\"h2\">\n                        Tag/Untag Files\n                    </Typography>\n                    <FileListChooser\n                        files={this.state.objectsDirFiles}\n                        alreadyChosenPaths={alreadyChosenPaths}\n                        onSelectionChange={this.associateFilesToCurrentTag}\n                        canSelect={canSelectFiles}\n                    />\n                </CardContent>\n            </Card>;\n            tagFilePreview = <Card>\n                <CardContent>\n                    <Typography variant=\"h2\">\n                        File Preview\n                    </Typography>\n                    <TagFilePreview\n                        contents={this.state.tagsFileContents}\n                    />\n                </CardContent>\n            </Card>;\n        }\n\n        return (\n            <Container maxWidth=\"xl\">\n                <Typography variant=\"h1\" color=\"primary\" >\n                    Dungeondraft Tag App\n                </Typography>\n\n                <Divider />\n\n                <Paper>\n                    <Accordion>\n                        <AccordionSummary\n                            expandIcon={<ExpandMoreIcon />}\n                            aria-controls=\"panel1a-content\"\n                            id=\"panel1a-header\"\n                        >\n                            <WarningIcon color=\"primary\" />\n                            <Typography color=\"textPrimary\" className={\"App-accordion-header\"}> Info</Typography>\n                            <Typography color=\"textSecondary\" align=\"center\">Bugs, browser support, privacy, source code, and a how-to demo gif</Typography>\n                        </AccordionSummary>\n                        <Alert severity=\"warning\">\n                            Please note that this app is in beta - there are likely to be bugs. If you come across any, let me know at <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://github.com/Oblongmana/dungeondraft-tag-app/issues\">https://github.com/Oblongmana/dungeondraft-tag-app/issues</a>. (Really it was one-day hack to relearn React and start learning material-ui, as you can tell from the simplistic UI<SentimentSatisfiedIcon/>)\n                        </Alert>\n                        <Alert severity=\"warning\">\n                            Please note that this app uses functionality that is not supported by all browsers, though is supported by most modern desktop browsers. If you see this message - you're likely using a modern browser! If you run into any issues though, see the issue reporting link above.\n                        </Alert>\n                        <Alert severity=\"info\">\n                            Your files will remain private, and will not be uploaded to any servers, or in any way transmitted anywhere - but feel free to verify this yourself! Source code can be viewed at <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://github.com/Oblongmana/dungeondraft-tag-app\">https://github.com/Oblongmana/dungeondraft-tag-app</a>.\n                        </Alert>\n                        <Alert severity=\"info\">\n                            If you'd like to watch a basic how-to, one is available at <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://github.com/Oblongmana/dungeondraft-tag-app#how-to-use\">https://github.com/Oblongmana/dungeondraft-tag-app#how-to-use</a>. I recommend just having a go though - this app won't modify anything on your system, it just produces a downloadable tag file at the end.\n                        </Alert>\n                    </Accordion>\n                </Paper>\n\n                <Divider/>\n\n                <Card>\n                    <CardContent>\n                        <Typography variant=\"h2\">\n                            Choose Existing Tag File (Optional)\n                        </Typography>\n                        <p style={{fontWeight: 'bold'}}>\n                            Choose your existing tag file, or proceed without selecting one if you want to create a new one from scratch. You can return here if you change your mind, but note that if you do, loading a tag file will overwrite any selections you've already made.\n                        </p>\n                        <p style={{fontWeight: 'bold'}}>\n                            Please note that the tag file will be reconciled with your selections, so if the tag file refers to objects that aren't in the directory you select, those will not be included in the output file\n                        </p>\n                        <Alert severity=\"warning\">\n                            The app does not handle Sets at present, but will not break any Sets already present in your tag file.\n                        </Alert>\n                        <p>\n                            <TagFilePicker onChange={this.handleInputTagsFileChange}/>\n                        </p>\n                    </CardContent>\n                </Card>\n\n                <Card>\n                    <CardContent>\n                        <Typography variant=\"h2\">\n                            Choose Folder\n                        </Typography>\n                        <p style={{fontWeight: 'bold'}}>Choose your objects folder (must be directly inside the \"textures\" folder)</p>\n                        <p><FolderPicker onChange={this.handleObjectsDirChange}/></p>\n                    </CardContent>\n                </Card>\n\n                {tagChooser}\n\n                {tagFileChooser}\n\n                {tagFilePreview}\n            </Container>\n            );\n        }\n    }\n\n    export default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import 'react-app-polyfill/stable';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport CssBaseline from '@material-ui/core/CssBaseline';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <CssBaseline />\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";"],"sourceRoot":""}